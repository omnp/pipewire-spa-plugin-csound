From 837750a0d94988f8456210beed1633d4e7d01119 Mon Sep 17 00:00:00 2001
From: "Olli M. (omnp)" <omnp@localhost>
Date: Fri, 19 Dec 2025 20:02:45 +0200
Subject: [PATCH 1/2] spa: filter-graph: csound: Csound (version 7) based
 filter effects

---
 spa/meson.build                          |   3 +
 spa/plugins/filter-graph/meson.build     |  10 +
 spa/plugins/filter-graph/plugin_csound.c | 375 +++++++++++++++++++++++
 3 files changed, 388 insertions(+)
 create mode 100644 spa/plugins/filter-graph/plugin_csound.c

diff --git a/spa/meson.build b/spa/meson.build
index f8acaec6a..bb4cbf653 100644
--- a/spa/meson.build
+++ b/spa/meson.build
@@ -131,6 +131,9 @@ if get_option('spa-plugins').allowed()
   endif
   summary({'Vulkan': have_vulkan}, bool_yn: true, section: 'Misc dependencies')
 
+  csound = cc.find_library('csound64', dirs: [], has_headers: ['csound/csound.h'], header_args: [])
+  summary({'Csound': csound.found()}, bool_yn: true, section: 'filter-graph')
+
   libcamera_dep = dependency('libcamera', version: '>= 0.2.0', required: get_option('libcamera'))
   summary({'libcamera': libcamera_dep.found()}, bool_yn: true, section: 'Backend')
 
diff --git a/spa/plugins/filter-graph/meson.build b/spa/plugins/filter-graph/meson.build
index 1995ae4c1..955be1166 100644
--- a/spa/plugins/filter-graph/meson.build
+++ b/spa/plugins/filter-graph/meson.build
@@ -135,4 +135,14 @@ spa_filter_graph_plugin_onnx = shared_library('spa-filter-graph-plugin-onnx',
 )
 endif
 
+if csound.found()
+spa_filter_graph_plugin_csound = shared_library('spa-filter-graph-plugin-csound',
+  [ 'plugin_csound.c' ],
+  include_directories : [configinc],
+  install : true,
+  install_dir : spa_plugindir / 'filter-graph',
+  dependencies : [ filter_graph_dependencies, csound]
+)
+endif
+
 
diff --git a/spa/plugins/filter-graph/plugin_csound.c b/spa/plugins/filter-graph/plugin_csound.c
new file mode 100644
index 000000000..3686431a0
--- /dev/null
+++ b/spa/plugins/filter-graph/plugin_csound.c
@@ -0,0 +1,375 @@
+/* Adapted from plugin_sofa.c */
+
+#include "config.h"
+
+#include <limits.h>
+
+#include <spa/utils/json.h>
+#include <spa/support/loop.h>
+#include <spa/support/log.h>
+
+#include "audio-plugin.h"
+#include "audio-dsp.h"
+
+#include <csound/csound.h>
+
+struct plugin {
+	struct spa_handle handle;
+	struct spa_fga_plugin plugin;
+
+	struct spa_fga_dsp *dsp;
+	struct spa_log *log;
+	struct spa_loop *data_loop;
+	struct spa_loop *main_loop;
+	uint32_t quantum_limit;
+};
+
+struct csound_impl {
+	struct plugin *plugin;
+
+	struct spa_fga_dsp *dsp;
+	struct spa_log *log;
+
+	unsigned long rate;
+	float *port[4];
+	int n_samples, blocksize;
+
+	struct MYSOFA_EASY *sofa;
+
+	CSOUND *csound;
+};
+
+static void * csound_instantiate(const struct spa_fga_plugin *plugin, const struct spa_fga_descriptor * Descriptor,
+		unsigned long SampleRate, int index, const char *config)
+{
+	struct plugin *pl = SPA_CONTAINER_OF(plugin, struct plugin, plugin);
+	struct csound_impl *impl;
+	struct spa_json it[1];
+	const char *val;
+	char key[256];
+	char filename[PATH_MAX] = "";
+	int len;
+
+	errno = EINVAL;
+	if (config == NULL) {
+		spa_log_error(pl->log, "csound: no config was given");
+		return NULL;
+	}
+
+	if (spa_json_begin_object(&it[0], config, strlen(config)) <= 0) {
+		spa_log_error(pl->log, "csound: expected object in config");
+		return NULL;
+	}
+
+	impl = calloc(1, sizeof(*impl));
+	if (impl == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	impl->plugin = pl;
+	impl->dsp = pl->dsp;
+	impl->log = pl->log;
+
+	while ((len = spa_json_object_next(&it[0], key, sizeof(key), &val)) > 0) {
+		if (spa_streq(key, "blocksize")) {
+			if (spa_json_parse_int(val, len, &impl->blocksize) <= 0) {
+				spa_log_error(impl->log, "csound:blocksize requires a number");
+				errno = EINVAL;
+				goto error;
+			}
+		}
+		else if (spa_streq(key, "filename")) {
+			if (spa_json_parse_stringn(val, len, filename, sizeof(filename)) <= 0) {
+				spa_log_error(impl->log, "csound:filename requires a string");
+				errno = EINVAL;
+				goto error;
+			}
+		}
+	}
+	if (!filename[0]) {
+		spa_log_error(impl->log, "csound:filename was not given");
+		errno = EINVAL;
+		goto error;
+	}
+
+	uint32_t rate = SampleRate;
+	char *rate_string = malloc(13);
+	spa_scnprintf(rate_string, 12, "-r%d", rate);
+	impl->csound = csoundCreate(NULL, NULL);
+	if (impl->csound == NULL) {
+		free(rate_string);
+		errno = EINVAL;
+		goto error;
+	}
+	csoundSetHostAudioIO(impl->csound);
+	csoundSetOption(impl->csound, "--nosound");
+	csoundSetOption(impl->csound, "-k1");
+	csoundSetOption(impl->csound, rate_string);
+	free(rate_string);
+
+	int res = CSOUND_SUCCESS;
+	const char *code = filename;
+	res = csoundCompileCSD(impl->csound, code, 0, 0);
+	if (res == CSOUND_SUCCESS) {
+		res = csoundStart(impl->csound);
+		if (res == CSOUND_SUCCESS);
+		else goto error;
+	} else goto error;
+
+
+	if (impl->blocksize <= 0)
+		impl->blocksize = SPA_CLAMP(impl->n_samples, 64, 256);
+
+	spa_log_info(impl->log, "using n_samples:%u %d blocksize sofa:%s", impl->n_samples,
+		impl->blocksize, filename);
+
+	impl->rate = SampleRate;
+	return impl;
+error:
+	free(impl);
+	return NULL;
+}
+
+static void csound_reload(void * Instance)
+{
+	struct csound_impl *impl = Instance;
+}
+
+struct free_data {
+	void *item[2];
+};
+
+static void csound_run(void * Instance, unsigned long SampleCount)
+{
+	struct csound_impl *impl = Instance;
+	MYFLT *spin = csoundGetSpin(impl->csound);
+	MYFLT const *spout = csoundGetSpout(impl->csound);
+
+//	uint32_t len = SPA_MIN(SampleCount, impl->plugin->quantum_limit);
+
+	for (uint32_t i = 0; i < SampleCount; i++) {
+		spin[0] = (MYFLT)impl->port[2][i];
+		spin[1] = (MYFLT)impl->port[3][i];
+		csoundPerformKsmps(impl->csound);
+		impl->port[0][i] = (float)spout[0];
+		impl->port[1][i] = (float)spout[1];
+	}
+}
+
+static void csound_connect_port(void * Instance, unsigned long Port,
+                        float * DataLocation)
+{
+	struct csound_impl *impl = Instance;
+	impl->port[Port] = DataLocation;
+}
+
+static void csound_cleanup(void * Instance)
+{
+	struct csound_impl *impl = Instance;
+	csoundDestroy(impl->csound);
+
+	free(impl);
+}
+
+static void csound_control_changed(void * Instance)
+{
+	csound_reload(Instance);
+}
+
+static void csound_activate(void * Instance)
+{
+	struct csound_impl *impl = Instance;
+}
+
+static void csound_deactivate(void * Instance)
+{
+	struct csound_impl *impl = Instance;
+}
+
+static struct spa_fga_port csound_ports[] = {
+	{ .index = 0,
+	  .name = "Out L",
+	  .flags = SPA_FGA_PORT_OUTPUT | SPA_FGA_PORT_AUDIO,
+	},
+	{ .index = 1,
+	  .name = "Out R",
+	  .flags = SPA_FGA_PORT_OUTPUT | SPA_FGA_PORT_AUDIO,
+	},
+	{ .index = 2,
+	  .name = "In L",
+	  .flags = SPA_FGA_PORT_INPUT | SPA_FGA_PORT_AUDIO,
+	},
+	{ .index = 3,
+	  .name = "In R",
+	  .flags = SPA_FGA_PORT_INPUT | SPA_FGA_PORT_AUDIO,
+	},
+};
+
+static const struct spa_fga_descriptor csound_desc = {
+	.name = "csound",
+
+	.n_ports = SPA_N_ELEMENTS(csound_ports),
+	.ports = csound_ports,
+
+	.instantiate = csound_instantiate,
+	.connect_port = csound_connect_port,
+	.control_changed = csound_control_changed,
+	.activate = csound_activate,
+	.deactivate = csound_deactivate,
+	.run = csound_run,
+	.cleanup = csound_cleanup,
+};
+
+static const struct spa_fga_descriptor * sofa_descriptor(unsigned long Index)
+{
+	switch(Index) {
+	case 0:
+		return &csound_desc;
+	}
+	return NULL;
+}
+
+
+static const struct spa_fga_descriptor *sofa_plugin_make_desc(void *plugin, const char *name)
+{
+	unsigned long i;
+	for (i = 0; ;i++) {
+		const struct spa_fga_descriptor *d = sofa_descriptor(i);
+		if (d == NULL)
+			break;
+		if (spa_streq(d->name, name))
+			return d;
+	}
+	return NULL;
+}
+
+static struct spa_fga_plugin_methods impl_plugin = {
+	SPA_VERSION_FGA_PLUGIN_METHODS,
+	.make_desc = sofa_plugin_make_desc,
+};
+
+static int impl_get_interface(struct spa_handle *handle, const char *type, void **interface)
+{
+	struct plugin *impl;
+
+	spa_return_val_if_fail(handle != NULL, -EINVAL);
+	spa_return_val_if_fail(interface != NULL, -EINVAL);
+
+	impl = (struct plugin *) handle;
+
+	if (spa_streq(type, SPA_TYPE_INTERFACE_FILTER_GRAPH_AudioPlugin))
+		*interface = &impl->plugin;
+	else
+		return -ENOENT;
+
+	return 0;
+}
+
+static int impl_clear(struct spa_handle *handle)
+{
+	return 0;
+}
+
+static size_t
+impl_get_size(const struct spa_handle_factory *factory,
+	      const struct spa_dict *params)
+{
+	return sizeof(struct plugin);
+}
+
+static int
+impl_init(const struct spa_handle_factory *factory,
+	  struct spa_handle *handle,
+	  const struct spa_dict *info,
+	  const struct spa_support *support,
+	  uint32_t n_support)
+{
+	struct plugin *impl;
+
+	handle->get_interface = impl_get_interface;
+	handle->clear = impl_clear;
+
+	impl = (struct plugin *) handle;
+
+	impl->plugin.iface = SPA_INTERFACE_INIT(
+			SPA_TYPE_INTERFACE_FILTER_GRAPH_AudioPlugin,
+			SPA_VERSION_FGA_PLUGIN,
+			&impl_plugin, impl);
+
+	impl->quantum_limit = 8192u;
+
+	impl->log = spa_support_find(support, n_support, SPA_TYPE_INTERFACE_Log);
+	impl->data_loop = spa_support_find(support, n_support, SPA_TYPE_INTERFACE_DataLoop);
+	impl->main_loop = spa_support_find(support, n_support, SPA_TYPE_INTERFACE_Loop);
+	impl->dsp = spa_support_find(support, n_support, SPA_TYPE_INTERFACE_FILTER_GRAPH_AudioDSP);
+
+	for (uint32_t i = 0; info && i < info->n_items; i++) {
+		const char *k = info->items[i].key;
+		const char *s = info->items[i].value;
+		if (spa_streq(k, "clock.quantum-limit"))
+			spa_atou32(s, &impl->quantum_limit, 0);
+		if (spa_streq(k, "filter.graph.audio.dsp"))
+			sscanf(s, "pointer:%p", &impl->dsp);
+	}
+
+	if (impl->data_loop == NULL || impl->main_loop == NULL) {
+		spa_log_error(impl->log, "%p: could not find a data/main loop", impl);
+		return -EINVAL;
+	}
+	if (impl->dsp == NULL) {
+		spa_log_error(impl->log, "%p: could not find DSP functions", impl);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct spa_interface_info impl_interfaces[] = {
+	{SPA_TYPE_INTERFACE_FILTER_GRAPH_AudioPlugin,},
+};
+
+static int
+impl_enum_interface_info(const struct spa_handle_factory *factory,
+			 const struct spa_interface_info **info,
+			 uint32_t *index)
+{
+	spa_return_val_if_fail(factory != NULL, -EINVAL);
+	spa_return_val_if_fail(info != NULL, -EINVAL);
+	spa_return_val_if_fail(index != NULL, -EINVAL);
+
+	switch (*index) {
+	case 0:
+		*info = &impl_interfaces[*index];
+		break;
+	default:
+		return 0;
+	}
+	(*index)++;
+	return 1;
+}
+
+static struct spa_handle_factory spa_fga_csound_plugin_factory = {
+	SPA_VERSION_HANDLE_FACTORY,
+	"filter.graph.plugin.csound",
+	NULL,
+	impl_get_size,
+	impl_init,
+	impl_enum_interface_info,
+};
+
+SPA_EXPORT
+int spa_handle_factory_enum(const struct spa_handle_factory **factory, uint32_t *index)
+{
+	spa_return_val_if_fail(factory != NULL, -EINVAL);
+	spa_return_val_if_fail(index != NULL, -EINVAL);
+
+	switch (*index) {
+	case 0:
+		*factory = &spa_fga_csound_plugin_factory;
+		break;
+	default:
+		return 0;
+	}
+	(*index)++;
+	return 1;
+}
-- 
2.52.0

